export interface NotAnArrayType<T> {
    readonly _: unique symbol;
    readonly _t: T;
}
export declare type ElemType<A> = IfElse<IsOptional<A>, NotAnArrayType<A>, A extends (infer Item)[] ? Item : NotAnArrayType<A>>;
export declare type Eq<A, B> = [A, B] extends [B, A] ? true : false;
export declare type Simplify<A, B> = Eq<A, B> extends true ? A : B;
export declare type IsOptional<A> = Or<ExtendsUndefined<A>, ExtendsNull<A>>;
declare type ExtendsUndefined<A> = Eq<A | undefined, A>;
declare type ExtendsNull<A> = Eq<A | null, A>;
declare type Or<A extends true | false, B extends true | false> = A extends true ? true : B;
export declare type IfElse<Condition extends true | false, Then, Else> = Condition extends true ? Then : Else;
export declare type RequireString<A, B> = IfElse<Eq<A, string>, B, ExpectedStringButGot<A>>;
interface ExpectedStringButGot<_T> {
    readonly _: unique symbol;
}
export declare type Prec<N> = N extends 6 ? 5 : N extends 5 ? 4 : N extends 4 ? 3 : N extends 3 ? 2 : N extends 2 ? 1 : N extends 1 ? 0 : never;
export declare type TuplePath<A, K> = K extends [] ? A : K extends [infer P, ...infer R] ? P extends keyof A ? TuplePath<A[P], R> : never : never;
export declare type DottedPath<A, K> = K extends keyof A ? A[K] : K extends `${infer P}.${infer R}` ? P extends keyof A ? DottedPath<A[P], R> : never : K extends '' ? A : never;
export declare type AnyTuple<N extends number, Acc extends any[] = []> = N extends 0 ? Acc : AnyTuple<Prec<N>, [...Acc, any]>;
export declare type Nth<A, N extends number> = A extends [
    ...AnyTuple<N>,
    infer U,
    ...any[]
] ? U : never;
/** Useful for working around distributive conditional types */
export declare type Unnaked<T> = T extends unknown ? T : never;
export {};
